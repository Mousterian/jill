#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const _INTTYPES_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 23;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const ____gwchar_t_defined: ::std::os::raw::c_uint = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\x00";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\x00";
pub const PRId8: &'static [u8; 2usize] = b"d\x00";
pub const PRId16: &'static [u8; 2usize] = b"d\x00";
pub const PRId32: &'static [u8; 2usize] = b"d\x00";
pub const PRId64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\x00";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIi8: &'static [u8; 2usize] = b"i\x00";
pub const PRIi16: &'static [u8; 2usize] = b"i\x00";
pub const PRIi32: &'static [u8; 2usize] = b"i\x00";
pub const PRIi64: &'static [u8; 3usize] = b"li\x00";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\x00";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\x00";
pub const PRIo8: &'static [u8; 2usize] = b"o\x00";
pub const PRIo16: &'static [u8; 2usize] = b"o\x00";
pub const PRIo32: &'static [u8; 2usize] = b"o\x00";
pub const PRIo64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\x00";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIu8: &'static [u8; 2usize] = b"u\x00";
pub const PRIu16: &'static [u8; 2usize] = b"u\x00";
pub const PRIu32: &'static [u8; 2usize] = b"u\x00";
pub const PRIu64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\x00";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIx8: &'static [u8; 2usize] = b"x\x00";
pub const PRIx16: &'static [u8; 2usize] = b"x\x00";
pub const PRIx32: &'static [u8; 2usize] = b"x\x00";
pub const PRIx64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\x00";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIX8: &'static [u8; 2usize] = b"X\x00";
pub const PRIX16: &'static [u8; 2usize] = b"X\x00";
pub const PRIX32: &'static [u8; 2usize] = b"X\x00";
pub const PRIX64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\x00";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\x00";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\x00";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\x00";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNd16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNd32: &'static [u8; 2usize] = b"d\x00";
pub const SCNd64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNi16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNi32: &'static [u8; 2usize] = b"i\x00";
pub const SCNi64: &'static [u8; 3usize] = b"li\x00";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\x00";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNu16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNu32: &'static [u8; 2usize] = b"u\x00";
pub const SCNu64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNo8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNo16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNo32: &'static [u8; 2usize] = b"o\x00";
pub const SCNo64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNx16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNx32: &'static [u8; 2usize] = b"x\x00";
pub const SCNx64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\x00";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\x00";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const _PTHREAD_H: ::std::os::raw::c_uint = 1;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SCHED_H: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const SCHED_OTHER: ::std::os::raw::c_uint = 0;
pub const SCHED_FIFO: ::std::os::raw::c_uint = 1;
pub const SCHED_RR: ::std::os::raw::c_uint = 2;
pub const __defined_schedparam: ::std::os::raw::c_uint = 1;
pub const __CPU_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _TIME_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TIME_H: ::std::os::raw::c_uint = 1;
pub const CLOCK_REALTIME: ::std::os::raw::c_uint = 0;
pub const CLOCK_MONOTONIC: ::std::os::raw::c_uint = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: ::std::os::raw::c_uint = 2;
pub const CLOCK_THREAD_CPUTIME_ID: ::std::os::raw::c_uint = 3;
pub const CLOCK_MONOTONIC_RAW: ::std::os::raw::c_uint = 4;
pub const CLOCK_REALTIME_COARSE: ::std::os::raw::c_uint = 5;
pub const CLOCK_MONOTONIC_COARSE: ::std::os::raw::c_uint = 6;
pub const CLOCK_BOOTTIME: ::std::os::raw::c_uint = 7;
pub const CLOCK_REALTIME_ALARM: ::std::os::raw::c_uint = 8;
pub const CLOCK_BOOTTIME_ALARM: ::std::os::raw::c_uint = 9;
pub const CLOCK_TAI: ::std::os::raw::c_uint = 11;
pub const TIMER_ABSTIME: ::std::os::raw::c_uint = 1;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const TIME_UTC: ::std::os::raw::c_uint = 1;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const _BITS_SETJMP_H: ::std::os::raw::c_uint = 1;
pub const PTHREAD_ONCE_INIT: ::std::os::raw::c_uint = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: ::std::os::raw::c_int = -1;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const _STRUCT_TIMEVAL: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const JACK_MAX_FRAMES: ::std::os::raw::c_uint = 4294967295;
pub const JACK_LOAD_INIT_LIMIT: ::std::os::raw::c_uint = 1024;
pub const JACK_DEFAULT_AUDIO_TYPE: &'static [u8; 24usize] =
    b"32 bit float mono audio\x00";
pub const JACK_DEFAULT_MIDI_TYPE: &'static [u8; 15usize] =
    b"8 bit raw midi\x00";
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(::std::mem::size_of::<imaxdiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (::std::mem::align_of::<imaxdiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const imaxdiv_t ) ) . quot as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const imaxdiv_t ) ) . rem as * const _ as usize
    } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for imaxdiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
            usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(::std::mem::size_of::<sched_param>() , 4usize , concat ! (
               "Size of: " , stringify ! ( sched_param ) ));
    assert_eq! (::std::mem::align_of::<sched_param>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sched_param ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const sched_param ) ) . __sched_priority as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sched_param ) , "::" ,
                stringify ! ( __sched_priority ) ));
}
impl Clone for sched_param {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_param() {
    assert_eq!(::std::mem::size_of::<__sched_param>() , 4usize , concat ! (
               "Size of: " , stringify ! ( __sched_param ) ));
    assert_eq! (::std::mem::align_of::<__sched_param>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sched_param ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __sched_param ) ) . __sched_priority as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sched_param ) , "::"
                , stringify ! ( __sched_priority ) ));
}
impl Clone for __sched_param {
    fn clone(&self) -> Self { *self }
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(::std::mem::size_of::<cpu_set_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( cpu_set_t ) ));
    assert_eq! (::std::mem::align_of::<cpu_set_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpu_set_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const cpu_set_t ) ) . __bits as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_set_t ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for cpu_set_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t)
                            -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param)
                          -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param)
                          -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(__pid: __pid_t, __policy: ::std::os::raw::c_int,
                              __param: *const sched_param)
                              -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int)
                                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int)
                                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec)
                                 -> ::std::os::raw::c_int;
}
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize , concat ! (
               "Size of: " , stringify ! ( tm ) ));
    assert_eq! (::std::mem::align_of::<tm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tm ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const tm ) ) . tm_sec as * const _ as usize } ,
    0usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_sec ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const tm ) ) . tm_min as * const _ as usize } ,
    4usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_min ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const tm ) ) . tm_hour as * const _ as usize }
    , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_hour ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const tm ) ) . tm_mday as * const _ as usize }
    , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mday ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const tm ) ) . tm_mon as * const _ as usize } ,
    16usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mon ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const tm ) ) . tm_year as * const _ as usize }
    , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_year ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const tm ) ) . tm_wday as * const _ as usize }
    , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_wday ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const tm ) ) . tm_yday as * const _ as usize }
    , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_yday ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const tm ) ) . tm_isdst as * const _ as usize }
    , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_isdst ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const tm ) ) . tm_gmtoff as * const _ as usize
    } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_gmtoff ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const tm ) ) . tm_zone as * const _ as usize }
    , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_zone ) ));
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::std::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
            as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
            usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                    __format: *const ::std::os::raw::c_char, __tp: *const tm)
                    -> usize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
    ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
    ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __locales as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
        const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
            * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
            * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __names as * const
        _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strftime_l(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                      __format: *const ::std::os::raw::c_char,
                      __tp: *const tm, __loc: __locale_t) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::std::os::raw::c_char)
                     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::std::os::raw::c_char)
                   -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__tzname"]
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "__daylight"]
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__timezone"]
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec,
                     __remaining: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec)
                        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec)
                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec)
                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(__clock_id: clockid_t,
                           __flags: ::std::os::raw::c_int,
                           __req: *const timespec, __rem: *mut timespec)
                           -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t)
                               -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut sigevent,
                        __timerid: *mut timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(__timerid: timer_t, __flags: ::std::os::raw::c_int,
                         __value: *const itimerspec,
                         __ovalue: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec)
                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: ::std::os::raw::c_int)
                        -> ::std::os::raw::c_int;
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_attr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
            as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
            as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
    concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
    concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
        const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t {
    pub __data: __BindgenUnionField<pthread_mutex_t___pthread_mutex_s>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 40usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
    40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
    8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
            __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
            __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
            __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
            __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
            __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
            __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
            __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
            __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
    ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
            as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
            as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
        _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutexattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
    ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
    concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t {
    pub __data: __BindgenUnionField<pthread_cond_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 48usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
    , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
    8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __lock
            as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock )
                ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
            __futex as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex
                ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
            __total_seq as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __total_seq ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
            __wakeup_seq as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wakeup_seq ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
            __woken_seq as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __woken_seq ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
            __mutex as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex
                ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
            __nwaiters as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nwaiters ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
            __broadcast_seq as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __broadcast_seq ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
            as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
            as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
            as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_condattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
    ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
    ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t {
    pub __data: __BindgenUnionField<pthread_rwlock_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
    56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
    8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
            __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock
                ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
            __nr_readers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
            __readers_wakeup as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers_wakeup ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
            __writer_wakeup as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer_wakeup ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
            __nr_readers_queued as * const _ as usize } , 16usize , concat
    ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers_queued ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
            __nr_writers_queued as * const _ as usize } , 20usize , concat
    ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_writers_queued ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
            __writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
            __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
            __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
            __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
            __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
            __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
    ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
    ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
        _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
        _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
        _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlockattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 8usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
    ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
    concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrier_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
    ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
    ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
        _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrierattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
    concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
    concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_1 =
    _bindgen_ty_1::PTHREAD_CREATE_JOINABLE;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_1 =
    _bindgen_ty_1::PTHREAD_CREATE_DETACHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1,
}
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_ADAPTIVE_NP;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
}
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_3 =
    _bindgen_ty_3::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_3 =
    _bindgen_ty_3::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_3 =
    _bindgen_ty_3::PTHREAD_MUTEX_ROBUST;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_3 =
    _bindgen_ty_3::PTHREAD_MUTEX_ROBUST;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_ROBUST = 1,
}
pub const PTHREAD_PRIO_NONE: _bindgen_ty_4 = _bindgen_ty_4::PTHREAD_PRIO_NONE;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_4 =
    _bindgen_ty_4::PTHREAD_PRIO_INHERIT;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_4 =
    _bindgen_ty_4::PTHREAD_PRIO_PROTECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2,
}
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_READER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_WRITER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_READER_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
}
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_6 =
    _bindgen_ty_6::PTHREAD_INHERIT_SCHED;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_6 =
    _bindgen_ty_6::PTHREAD_EXPLICIT_SCHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1,
}
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_7 =
    _bindgen_ty_7::PTHREAD_SCOPE_SYSTEM;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_7 =
    _bindgen_ty_7::PTHREAD_SCOPE_PROCESS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1,
}
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_8 =
    _bindgen_ty_8::PTHREAD_PROCESS_PRIVATE;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_8 =
    _bindgen_ty_8::PTHREAD_PROCESS_SHARED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(::std::mem::size_of::<_pthread_cleanup_buffer>() , 32usize ,
    concat ! (
               "Size of: " , stringify ! ( _pthread_cleanup_buffer ) ));
    assert_eq! (::std::mem::align_of::<_pthread_cleanup_buffer>() , 8usize ,
    concat ! (
                "Alignment of " , stringify ! ( _pthread_cleanup_buffer ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _pthread_cleanup_buffer ) ) . __routine
            as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __routine ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _pthread_cleanup_buffer ) ) . __arg as *
        const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __arg ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _pthread_cleanup_buffer ) ) .
            __canceltype as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __canceltype ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _pthread_cleanup_buffer ) ) . __prev as *
        const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __prev ) ));
}
impl Clone for _pthread_cleanup_buffer {
    fn clone(&self) -> Self { *self }
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_9 =
    _bindgen_ty_9::PTHREAD_CANCEL_ENABLE;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_9 =
    _bindgen_ty_9::PTHREAD_CANCEL_DISABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1,
}
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_10 =
    _bindgen_ty_10::PTHREAD_CANCEL_DEFERRED;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_10 =
    _bindgen_ty_10::PTHREAD_CANCEL_ASYNCHRONOUS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1,
}
extern "C" {
    pub fn pthread_create(__newthread: *mut pthread_t,
                          __attr: *const pthread_attr_t,
                          __start_routine:
                          ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut ::std::os::raw::c_void)
                                                                     ->
                                                                     *mut ::std::os::raw::c_void>,
                          __arg: *mut ::std::os::raw::c_void)
                          -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(__th: pthread_t,
                        __thread_return: *mut *mut ::std::os::raw::c_void)
                        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t)
                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t)
                             -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t)
                                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(__attr: *const pthread_attr_t,
                                       __detachstate:
                                       *mut ::std::os::raw::c_int)
                                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(__attr: *mut pthread_attr_t,
                                       __detachstate: ::std::os::raw::c_int)
                                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(__attr: *const pthread_attr_t,
                                     __guardsize: *mut usize)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(__attr: *mut pthread_attr_t,
                                     __guardsize: usize)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(__attr: *const pthread_attr_t,
                                      __param: *mut sched_param)
                                      -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(__attr: *mut pthread_attr_t,
                                      __param: *const sched_param)
                                      -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(__attr: *const pthread_attr_t,
                                       __policy: *mut ::std::os::raw::c_int)
                                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(__attr: *mut pthread_attr_t,
                                       __policy: ::std::os::raw::c_int)
                                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(__attr: *const pthread_attr_t,
                                        __inherit: *mut ::std::os::raw::c_int)
                                        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(__attr: *mut pthread_attr_t,
                                        __inherit: ::std::os::raw::c_int)
                                        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(__attr: *const pthread_attr_t,
                                 __scope: *mut ::std::os::raw::c_int)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t,
                                 __scope: ::std::os::raw::c_int)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(__attr: *const pthread_attr_t,
                                     __stackaddr:
                                     *mut *mut ::std::os::raw::c_void)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(__attr: *mut pthread_attr_t,
                                     __stackaddr: *mut ::std::os::raw::c_void)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(__attr: *const pthread_attr_t,
                                     __stacksize: *mut usize)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(__attr: *mut pthread_attr_t,
                                     __stacksize: usize)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(__attr: *const pthread_attr_t,
                                 __stackaddr:
                                 *mut *mut ::std::os::raw::c_void,
                                 __stacksize: *mut usize)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(__attr: *mut pthread_attr_t,
                                 __stackaddr: *mut ::std::os::raw::c_void,
                                 __stacksize: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(__target_thread: pthread_t,
                                 __policy: ::std::os::raw::c_int,
                                 __param: *const sched_param)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(__target_thread: pthread_t,
                                 __policy: *mut ::std::os::raw::c_int,
                                 __param: *mut sched_param)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(__target_thread: pthread_t,
                                __prio: ::std::os::raw::c_int)
                                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(__once_control: *mut pthread_once_t,
                        __init_routine:
                        ::std::option::Option<unsafe extern "C" fn()>)
                        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(__state: ::std::os::raw::c_int,
                                  __oldstate: *mut ::std::os::raw::c_int)
                                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(__type: ::std::os::raw::c_int,
                                 __oldtype: *mut ::std::os::raw::c_int)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>() ,
    72usize , concat ! (
               "Size of: " , stringify ! (
               __pthread_unwind_buf_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>()
    , 8usize , concat ! (
                "Alignment of " , stringify ! (
                __pthread_unwind_buf_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __pthread_unwind_buf_t__bindgen_ty_1 ) )
            . __cancel_jmp_buf as * const _ as usize } , 0usize , concat !
    (
                "Alignment of field: " , stringify ! (
                __pthread_unwind_buf_t__bindgen_ty_1 ) , "::" , stringify ! (
                __cancel_jmp_buf ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __pthread_unwind_buf_t__bindgen_ty_1 ) )
            . __mask_was_saved as * const _ as usize } , 64usize , concat
    ! (
                "Alignment of field: " , stringify ! (
                __pthread_unwind_buf_t__bindgen_ty_1 ) , "::" , stringify ! (
                __mask_was_saved ) ));
}
impl Clone for __pthread_unwind_buf_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(::std::mem::size_of::<__pthread_unwind_buf_t>() , 104usize ,
    concat ! ( "Size of: " , stringify ! ( __pthread_unwind_buf_t )
               ));
    assert_eq! (::std::mem::align_of::<__pthread_unwind_buf_t>() , 8usize ,
    concat ! (
                "Alignment of " , stringify ! ( __pthread_unwind_buf_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __pthread_unwind_buf_t ) ) .
            __cancel_jmp_buf as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_unwind_buf_t
                ) , "::" , stringify ! ( __cancel_jmp_buf ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __pthread_unwind_buf_t ) ) . __pad as *
        const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_unwind_buf_t
                ) , "::" , stringify ! ( __pad ) ));
}
impl Clone for __pthread_unwind_buf_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(::std::mem::size_of::<__pthread_cleanup_frame>() , 24usize ,
    concat ! (
               "Size of: " , stringify ! ( __pthread_cleanup_frame ) ));
    assert_eq! (::std::mem::align_of::<__pthread_cleanup_frame>() , 8usize ,
    concat ! (
                "Alignment of " , stringify ! ( __pthread_cleanup_frame ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __pthread_cleanup_frame ) ) .
            __cancel_routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __cancel_routine ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __pthread_cleanup_frame ) ) .
            __cancel_arg as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __cancel_arg ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __pthread_cleanup_frame ) ) . __do_it as
            * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __do_it ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __pthread_cleanup_frame ) ) .
            __cancel_type as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __cancel_type ) ));
}
impl Clone for __pthread_cleanup_frame {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag,
                       __savemask: ::std::os::raw::c_int)
                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(__mutex: *mut pthread_mutex_t,
                              __mutexattr: *const pthread_mutexattr_t)
                              -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t)
                              -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(__mutex: *mut pthread_mutex_t,
                                   __abstime: *const timespec)
                                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t)
                                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(__mutex: *const pthread_mutex_t,
                                        __prioceiling:
                                        *mut ::std::os::raw::c_int)
                                        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(__mutex: *mut pthread_mutex_t,
                                        __prioceiling: ::std::os::raw::c_int,
                                        __old_ceiling:
                                        *mut ::std::os::raw::c_int)
                                        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t)
                                    -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t)
                                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(__attr: *const pthread_mutexattr_t,
                                        __pshared: *mut ::std::os::raw::c_int)
                                        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(__attr: *mut pthread_mutexattr_t,
                                        __pshared: ::std::os::raw::c_int)
                                        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(__attr: *const pthread_mutexattr_t,
                                     __kind: *mut ::std::os::raw::c_int)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(__attr: *mut pthread_mutexattr_t,
                                     __kind: ::std::os::raw::c_int)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(__attr: *const pthread_mutexattr_t,
                                         __protocol:
                                         *mut ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(__attr: *mut pthread_mutexattr_t,
                                         __protocol: ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(__attr:
                                            *const pthread_mutexattr_t,
                                            __prioceiling:
                                            *mut ::std::os::raw::c_int)
                                            -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(__attr: *mut pthread_mutexattr_t,
                                            __prioceiling:
                                            ::std::os::raw::c_int)
                                            -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(__attr: *const pthread_mutexattr_t,
                                       __robustness:
                                       *mut ::std::os::raw::c_int)
                                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(__attr: *mut pthread_mutexattr_t,
                                       __robustness: ::std::os::raw::c_int)
                                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(__rwlock: *mut pthread_rwlock_t,
                               __attr: *const pthread_rwlockattr_t)
                               -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t)
                                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t)
                                    -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const timespec)
                                      -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t)
                                    -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const timespec)
                                      -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t)
                                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t)
                                      -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(__attr: *const pthread_rwlockattr_t,
                                         __pshared:
                                         *mut ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(__attr: *mut pthread_rwlockattr_t,
                                         __pshared: ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(__attr: *const pthread_rwlockattr_t,
                                         __pref: *mut ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(__attr: *mut pthread_rwlockattr_t,
                                         __pref: ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(__cond: *mut pthread_cond_t,
                             __cond_attr: *const pthread_condattr_t)
                             -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t)
                                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t)
                               -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t)
                                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(__cond: *mut pthread_cond_t,
                             __mutex: *mut pthread_mutex_t)
                             -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(__cond: *mut pthread_cond_t,
                                  __mutex: *mut pthread_mutex_t,
                                  __abstime: *const timespec)
                                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t)
                                    -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(__attr: *const pthread_condattr_t,
                                       __pshared: *mut ::std::os::raw::c_int)
                                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(__attr: *mut pthread_condattr_t,
                                       __pshared: ::std::os::raw::c_int)
                                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(__attr: *const pthread_condattr_t,
                                     __clock_id: *mut __clockid_t)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(__attr: *mut pthread_condattr_t,
                                     __clock_id: __clockid_t)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(__lock: *mut pthread_spinlock_t,
                             __pshared: ::std::os::raw::c_int)
                             -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t)
                                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t)
                             -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t)
                                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t)
                               -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(__barrier: *mut pthread_barrier_t,
                                __attr: *const pthread_barrierattr_t,
                                __count: ::std::os::raw::c_uint)
                                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t)
                                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t)
                                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t)
                                    -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
                                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(__attr:
                                          *const pthread_barrierattr_t,
                                          __pshared:
                                          *mut ::std::os::raw::c_int)
                                          -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(__attr: *mut pthread_barrierattr_t,
                                          __pshared: ::std::os::raw::c_int)
                                          -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(__key: *mut pthread_key_t,
                              __destr_function:
                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::std::os::raw::c_void)>)
                              -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t)
                               -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(__key: pthread_key_t,
                               __pointer: *const ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(__thread_id: pthread_t,
                                 __clock_id: *mut __clockid_t)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(__prepare:
                          ::std::option::Option<unsafe extern "C" fn()>,
                          __parent:
                          ::std::option::Option<unsafe extern "C" fn()>,
                          __child:
                          ::std::option::Option<unsafe extern "C" fn()>)
                          -> ::std::os::raw::c_int;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
            usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
                         -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
                         -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
                           -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type jack_native_thread_t = pthread_t;
pub type jack_uuid_t = u64;
pub type jack_shmsize_t = i32;
pub type jack_nframes_t = u32;
pub type jack_time_t = u64;
pub type jack_intclient_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jack_port {
    _unused: [u8; 0],
}
pub type jack_port_t = _jack_port;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jack_client {
    _unused: [u8; 0],
}
pub type jack_client_t = _jack_client;
pub type jack_port_id_t = u32;
pub type jack_port_type_id_t = u32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum JackOptions {
    JackNullOption = 0,
    JackNoStartServer = 1,
    JackUseExactName = 2,
    JackServerName = 4,
    JackLoadName = 8,
    JackLoadInit = 16,
    JackSessionID = 32,
}
pub use self::JackOptions as jack_options_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum JackStatus {
    JackFailure = 1,
    JackInvalidOption = 2,
    JackNameNotUnique = 4,
    JackServerStarted = 8,
    JackServerFailed = 16,
    JackServerError = 32,
    JackNoSuchClient = 64,
    JackLoadFailure = 128,
    JackInitFailure = 256,
    JackShmFailure = 512,
    JackVersionError = 1024,
    JackBackendError = 2048,
    JackClientZombie = 4096,
}
pub use self::JackStatus as jack_status_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum JackLatencyCallbackMode {
    JackCaptureLatency = 0,
    JackPlaybackLatency = 1,
}
pub use self::JackLatencyCallbackMode as jack_latency_callback_mode_t;
pub type JackLatencyCallback =
::std::option::Option<unsafe extern "C" fn(mode:
                                           jack_latency_callback_mode_t,
                                           arg:
                                           *mut ::std::os::raw::c_void)>;
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct _jack_latency_range {
    pub min: jack_nframes_t,
    pub max: jack_nframes_t,
}
#[test]
fn bindgen_test_layout__jack_latency_range() {
    assert_eq!(::std::mem::size_of::<_jack_latency_range>() , 8usize , concat
    ! ( "Size of: " , stringify ! ( _jack_latency_range ) ));
    assert_eq! (::std::mem::align_of::<_jack_latency_range>() , 1usize ,
    concat ! (
                "Alignment of " , stringify ! ( _jack_latency_range ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_latency_range ) ) . min as * const
        _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_latency_range ) ,
                "::" , stringify ! ( min ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_latency_range ) ) . max as * const
        _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_latency_range ) ,
                "::" , stringify ! ( max ) ));
}
impl Clone for _jack_latency_range {
    fn clone(&self) -> Self { *self }
}
pub type jack_latency_range_t = _jack_latency_range;
pub type JackProcessCallback =
::std::option::Option<unsafe extern "C" fn(nframes: jack_nframes_t,
                                           arg:
                                           *mut ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>;
pub type JackThreadCallback =
::std::option::Option<unsafe extern "C" fn(arg:
                                           *mut ::std::os::raw::c_void)
                                           -> *mut ::std::os::raw::c_void>;
pub type JackThreadInitCallback =
::std::option::Option<unsafe extern "C" fn(arg:
                                           *mut ::std::os::raw::c_void)>;
pub type JackGraphOrderCallback =
::std::option::Option<unsafe extern "C" fn(arg:
                                           *mut ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>;
pub type JackXRunCallback =
::std::option::Option<unsafe extern "C" fn(arg:
                                           *mut ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>;
pub type JackBufferSizeCallback =
::std::option::Option<unsafe extern "C" fn(nframes: jack_nframes_t,
                                           arg:
                                           *mut ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>;
pub type JackSampleRateCallback =
::std::option::Option<unsafe extern "C" fn(nframes: jack_nframes_t,
                                           arg:
                                           *mut ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>;
pub type JackPortRegistrationCallback =
::std::option::Option<unsafe extern "C" fn(port: jack_port_id_t,
                                           arg1: ::std::os::raw::c_int,
                                           arg:
                                           *mut ::std::os::raw::c_void)>;
pub type JackClientRegistrationCallback =
::std::option::Option<unsafe extern "C" fn(name:
                                           *const ::std::os::raw::c_char,
                                           arg1: ::std::os::raw::c_int,
                                           arg:
                                           *mut ::std::os::raw::c_void)>;
pub type JackPortConnectCallback =
::std::option::Option<unsafe extern "C" fn(a: jack_port_id_t,
                                           b: jack_port_id_t,
                                           connect: ::std::os::raw::c_int,
                                           arg:
                                           *mut ::std::os::raw::c_void)>;
pub type JackPortRenameCallback =
::std::option::Option<unsafe extern "C" fn(port: jack_port_id_t,
                                           old_name:
                                           *const ::std::os::raw::c_char,
                                           new_name:
                                           *const ::std::os::raw::c_char,
                                           arg:
                                           *mut ::std::os::raw::c_void)>;
pub type JackFreewheelCallback =
::std::option::Option<unsafe extern "C" fn(starting:
                                           ::std::os::raw::c_int,
                                           arg:
                                           *mut ::std::os::raw::c_void)>;
pub type JackShutdownCallback =
::std::option::Option<unsafe extern "C" fn(arg:
                                           *mut ::std::os::raw::c_void)>;
pub type JackInfoShutdownCallback =
::std::option::Option<unsafe extern "C" fn(code: jack_status_t,
                                           reason:
                                           *const ::std::os::raw::c_char,
                                           arg:
                                           *mut ::std::os::raw::c_void)>;
pub type jack_default_audio_sample_t = f32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum JackPortFlags {
    JackPortIsInput = 1,
    JackPortIsOutput = 2,
    JackPortIsPhysical = 4,
    JackPortCanMonitor = 8,
    JackPortIsTerminal = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum jack_transport_state_t {
    JackTransportStopped = 0,
    JackTransportRolling = 1,
    JackTransportLooping = 2,
    JackTransportStarting = 3,
    JackTransportNetStarting = 4,
}
pub type jack_unique_t = u64;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum jack_position_bits_t {
    JackPositionBBT = 16,
    JackPositionTimecode = 32,
    JackBBTFrameOffset = 64,
    JackAudioVideoRatio = 128,
    JackVideoFrameOffset = 256,
}
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct _jack_position {
    pub unique_1: jack_unique_t,
    pub usecs: jack_time_t,
    pub frame_rate: jack_nframes_t,
    pub frame: jack_nframes_t,
    pub valid: jack_position_bits_t,
    pub bar: i32,
    pub beat: i32,
    pub tick: i32,
    pub bar_start_tick: f64,
    pub beats_per_bar: f32,
    pub beat_type: f32,
    pub ticks_per_beat: f64,
    pub beats_per_minute: f64,
    pub frame_time: f64,
    pub next_time: f64,
    pub bbt_offset: jack_nframes_t,
    pub audio_frames_per_video_frame: f32,
    pub video_offset: jack_nframes_t,
    pub padding: [i32; 7usize],
    pub unique_2: jack_unique_t,
}
#[test]
fn bindgen_test_layout__jack_position() {
    assert_eq!(::std::mem::size_of::<_jack_position>() , 136usize , concat ! (
               "Size of: " , stringify ! ( _jack_position ) ));
    assert_eq! (::std::mem::align_of::<_jack_position>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( _jack_position ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . unique_1 as * const
        _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( unique_1 ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . usecs as * const _
            as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( usecs ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . frame_rate as *
        const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( frame_rate ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . frame as * const _
            as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( frame ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . valid as * const _
            as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( valid ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . bar as * const _ as
            usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( bar ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . beat as * const _ as
            usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( beat ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . tick as * const _ as
            usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( tick ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . bar_start_tick as *
        const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( bar_start_tick ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . beats_per_bar as *
        const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( beats_per_bar ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . beat_type as * const
        _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( beat_type ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . ticks_per_beat as *
        const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( ticks_per_beat ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . beats_per_minute as
            * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( beats_per_minute ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . frame_time as *
        const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( frame_time ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . next_time as * const
        _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( next_time ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . bbt_offset as *
        const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( bbt_offset ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) .
            audio_frames_per_video_frame as * const _ as usize } , 92usize
    , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( audio_frames_per_video_frame ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . video_offset as *
        const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( video_offset ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . padding as * const _
            as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( padding ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _jack_position ) ) . unique_2 as * const
        _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _jack_position ) , "::"
                , stringify ! ( unique_2 ) ));
}
impl Clone for _jack_position {
    fn clone(&self) -> Self { *self }
}
pub type jack_position_t = _jack_position;
pub type JackSyncCallback =
::std::option::Option<unsafe extern "C" fn(state: jack_transport_state_t,
                                           pos: *mut jack_position_t,
                                           arg:
                                           *mut ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>;
pub type JackTimebaseCallback =
::std::option::Option<unsafe extern "C" fn(state: jack_transport_state_t,
                                           nframes: jack_nframes_t,
                                           pos: *mut jack_position_t,
                                           new_pos: ::std::os::raw::c_int,
                                           arg:
                                           *mut ::std::os::raw::c_void)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum jack_transport_bits_t {
    JackTransportState = 1,
    JackTransportPosition = 2,
    JackTransportLoop = 4,
    JackTransportSMPTE = 8,
    JackTransportBBT = 16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jack_transport_info_t {
    pub frame_rate: jack_nframes_t,
    pub usecs: jack_time_t,
    pub valid: jack_transport_bits_t,
    pub transport_state: jack_transport_state_t,
    pub frame: jack_nframes_t,
    pub loop_start: jack_nframes_t,
    pub loop_end: jack_nframes_t,
    pub smpte_offset: ::std::os::raw::c_long,
    pub smpte_frame_rate: f32,
    pub bar: ::std::os::raw::c_int,
    pub beat: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub bar_start_tick: f64,
    pub beats_per_bar: f32,
    pub beat_type: f32,
    pub ticks_per_beat: f64,
    pub beats_per_minute: f64,
}
#[test]
fn bindgen_test_layout_jack_transport_info_t() {
    assert_eq!(::std::mem::size_of::<jack_transport_info_t>() , 96usize ,
    concat ! ( "Size of: " , stringify ! ( jack_transport_info_t )
               ));
    assert_eq! (::std::mem::align_of::<jack_transport_info_t>() , 8usize ,
    concat ! (
                "Alignment of " , stringify ! ( jack_transport_info_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) . frame_rate as
            * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( frame_rate ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) . usecs as *
        const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( usecs ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) . valid as *
        const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( valid ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) .
            transport_state as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( transport_state ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) . frame as *
        const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( frame ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) . loop_start as
            * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( loop_start ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) . loop_end as *
        const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( loop_end ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) . smpte_offset
            as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( smpte_offset ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) .
            smpte_frame_rate as * const _ as usize } , 48usize , concat !
    (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( smpte_frame_rate ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) . bar as *
        const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( bar ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) . beat as *
        const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( beat ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) . tick as *
        const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( tick ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) .
            bar_start_tick as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( bar_start_tick ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) . beats_per_bar
            as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( beats_per_bar ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) . beat_type as
            * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( beat_type ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) .
            ticks_per_beat as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( ticks_per_beat ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const jack_transport_info_t ) ) .
            beats_per_minute as * const _ as usize } , 88usize , concat !
    (
                "Alignment of field: " , stringify ! ( jack_transport_info_t )
                , "::" , stringify ! ( beats_per_minute ) ));
}
impl Clone for jack_transport_info_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn jack_release_timebase(client: *mut jack_client_t)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_sync_callback(client: *mut jack_client_t,
                                  sync_callback: JackSyncCallback,
                                  arg: *mut ::std::os::raw::c_void)
                                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_sync_timeout(client: *mut jack_client_t,
                                 timeout: jack_time_t)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_timebase_callback(client: *mut jack_client_t,
                                      conditional: ::std::os::raw::c_int,
                                      timebase_callback: JackTimebaseCallback,
                                      arg: *mut ::std::os::raw::c_void)
                                      -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_transport_locate(client: *mut jack_client_t,
                                 frame: jack_nframes_t)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_transport_query(client: *const jack_client_t,
                                pos: *mut jack_position_t)
                                -> jack_transport_state_t;
}
extern "C" {
    pub fn jack_get_current_transport_frame(client: *const jack_client_t)
                                            -> jack_nframes_t;
}
extern "C" {
    pub fn jack_transport_reposition(client: *mut jack_client_t,
                                     pos: *const jack_position_t)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_transport_start(client: *mut jack_client_t);
}
extern "C" {
    pub fn jack_transport_stop(client: *mut jack_client_t);
}
extern "C" {
    pub fn jack_get_transport_info(client: *mut jack_client_t,
                                   tinfo: *mut jack_transport_info_t);
}
extern "C" {
    pub fn jack_set_transport_info(client: *mut jack_client_t,
                                   tinfo: *mut jack_transport_info_t);
}
extern "C" {
    pub fn jack_get_version(major_ptr: *mut ::std::os::raw::c_int,
                            minor_ptr: *mut ::std::os::raw::c_int,
                            micro_ptr: *mut ::std::os::raw::c_int,
                            proto_ptr: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn jack_get_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jack_client_open(client_name: *const ::std::os::raw::c_char,
                            options: jack_options_t,
                            status: *mut jack_status_t, ...)
                            -> *mut jack_client_t;
}
extern "C" {
    pub fn jack_client_new(client_name: *const ::std::os::raw::c_char)
                           -> *mut jack_client_t;
}
extern "C" {
    pub fn jack_client_close(client: *mut jack_client_t)
                             -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_client_name_size() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_get_client_name(client: *mut jack_client_t)
                                -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jack_get_uuid_for_client_name(client: *mut jack_client_t,
                                         client_name:
                                         *const ::std::os::raw::c_char)
                                         -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jack_get_client_name_by_uuid(client: *mut jack_client_t,
                                        client_uuid:
                                        *const ::std::os::raw::c_char)
                                        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jack_internal_client_new(client_name:
                                    *const ::std::os::raw::c_char,
                                    load_name: *const ::std::os::raw::c_char,
                                    load_init: *const ::std::os::raw::c_char)
                                    -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_internal_client_close(client_name:
                                      *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn jack_activate(client: *mut jack_client_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_deactivate(client: *mut jack_client_t)
                           -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_get_client_pid(name: *const ::std::os::raw::c_char)
                               -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_client_thread_id(client: *mut jack_client_t)
                                 -> jack_native_thread_t;
}
extern "C" {
    pub fn jack_is_realtime(client: *mut jack_client_t)
                            -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_thread_wait(client: *mut jack_client_t,
                            status: ::std::os::raw::c_int) -> jack_nframes_t;
}
extern "C" {
    pub fn jack_cycle_wait(client: *mut jack_client_t) -> jack_nframes_t;
}
extern "C" {
    pub fn jack_cycle_signal(client: *mut jack_client_t,
                             status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jack_set_process_thread(client: *mut jack_client_t,
                                   thread_callback: JackThreadCallback,
                                   arg: *mut ::std::os::raw::c_void)
                                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_thread_init_callback(client: *mut jack_client_t,
                                         thread_init_callback:
                                         JackThreadInitCallback,
                                         arg: *mut ::std::os::raw::c_void)
                                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_on_shutdown(client: *mut jack_client_t,
                            shutdown_callback: JackShutdownCallback,
                            arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn jack_on_info_shutdown(client: *mut jack_client_t,
                                 shutdown_callback: JackInfoShutdownCallback,
                                 arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn jack_set_process_callback(client: *mut jack_client_t,
                                     process_callback: JackProcessCallback,
                                     arg: *mut ::std::os::raw::c_void)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_freewheel_callback(client: *mut jack_client_t,
                                       freewheel_callback:
                                       JackFreewheelCallback,
                                       arg: *mut ::std::os::raw::c_void)
                                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_buffer_size_callback(client: *mut jack_client_t,
                                         bufsize_callback:
                                         JackBufferSizeCallback,
                                         arg: *mut ::std::os::raw::c_void)
                                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_sample_rate_callback(client: *mut jack_client_t,
                                         srate_callback:
                                         JackSampleRateCallback,
                                         arg: *mut ::std::os::raw::c_void)
                                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_client_registration_callback(client: *mut jack_client_t,
                                                 registration_callback:
                                                 JackClientRegistrationCallback,
                                                 arg:
                                                 *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_port_registration_callback(client: *mut jack_client_t,
                                               registration_callback:
                                               JackPortRegistrationCallback,
                                               arg:
                                               *mut ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_port_connect_callback(client: *mut jack_client_t,
                                          connect_callback:
                                          JackPortConnectCallback,
                                          arg: *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_port_rename_callback(client: *mut jack_client_t,
                                         rename_callback:
                                         JackPortRenameCallback,
                                         arg: *mut ::std::os::raw::c_void)
                                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_graph_order_callback(client: *mut jack_client_t,
                                         graph_callback:
                                         JackGraphOrderCallback,
                                         arg1: *mut ::std::os::raw::c_void)
                                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_xrun_callback(client: *mut jack_client_t,
                                  xrun_callback: JackXRunCallback,
                                  arg: *mut ::std::os::raw::c_void)
                                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_latency_callback(client: *mut jack_client_t,
                                     latency_callback: JackLatencyCallback,
                                     arg1: *mut ::std::os::raw::c_void)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_freewheel(client: *mut jack_client_t,
                              onoff: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_set_buffer_size(client: *mut jack_client_t,
                                nframes: jack_nframes_t)
                                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_get_sample_rate(arg1: *mut jack_client_t) -> jack_nframes_t;
}
extern "C" {
    pub fn jack_get_buffer_size(arg1: *mut jack_client_t) -> jack_nframes_t;
}
extern "C" {
    pub fn jack_engine_takeover_timebase(arg1: *mut jack_client_t)
                                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_cpu_load(client: *mut jack_client_t) -> f32;
}
extern "C" {
    pub fn jack_port_register(client: *mut jack_client_t,
                              port_name: *const ::std::os::raw::c_char,
                              port_type: *const ::std::os::raw::c_char,
                              flags: ::std::os::raw::c_ulong,
                              buffer_size: ::std::os::raw::c_ulong)
                              -> *mut jack_port_t;
}
extern "C" {
    pub fn jack_port_unregister(client: *mut jack_client_t,
                                port: *mut jack_port_t)
                                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_get_buffer(port: *mut jack_port_t, arg1: jack_nframes_t)
                                -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn jack_port_uuid(port: *const jack_port_t) -> jack_uuid_t;
}
extern "C" {
    pub fn jack_port_name(port: *const jack_port_t)
                          -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jack_port_short_name(port: *const jack_port_t)
                                -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jack_port_flags(port: *const jack_port_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_type(port: *const jack_port_t)
                          -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jack_port_type_id(port: *const jack_port_t) -> jack_port_type_id_t;
}
extern "C" {
    pub fn jack_port_is_mine(client: *const jack_client_t,
                             port: *const jack_port_t)
                             -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_connected(port: *const jack_port_t)
                               -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_connected_to(port: *const jack_port_t,
                                  port_name: *const ::std::os::raw::c_char)
                                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_get_connections(port: *const jack_port_t)
                                     -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jack_port_get_all_connections(client: *const jack_client_t,
                                         port: *const jack_port_t)
                                         -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jack_port_tie(src: *mut jack_port_t, dst: *mut jack_port_t)
                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_untie(port: *mut jack_port_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_set_name(port: *mut jack_port_t,
                              port_name: *const ::std::os::raw::c_char)
                              -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_rename(client: *mut jack_client_t,
                            port: *mut jack_port_t,
                            port_name: *const ::std::os::raw::c_char)
                            -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_set_alias(port: *mut jack_port_t,
                               alias: *const ::std::os::raw::c_char)
                               -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_unset_alias(port: *mut jack_port_t,
                                 alias: *const ::std::os::raw::c_char)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_get_aliases(port: *const jack_port_t,
                                 aliases:
                                 *const *const ::std::os::raw::c_char)
                                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_request_monitor(port: *mut jack_port_t,
                                     onoff: ::std::os::raw::c_int)
                                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_request_monitor_by_name(client: *mut jack_client_t,
                                             port_name:
                                             *const ::std::os::raw::c_char,
                                             onoff: ::std::os::raw::c_int)
                                             -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_ensure_monitor(port: *mut jack_port_t,
                                    onoff: ::std::os::raw::c_int)
                                    -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_monitoring_input(port: *mut jack_port_t)
                                      -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_connect(client: *mut jack_client_t,
                        source_port: *const ::std::os::raw::c_char,
                        destination_port: *const ::std::os::raw::c_char)
                        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_disconnect(client: *mut jack_client_t,
                           source_port: *const ::std::os::raw::c_char,
                           destination_port: *const ::std::os::raw::c_char)
                           -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_disconnect(client: *mut jack_client_t,
                                port: *mut jack_port_t)
                                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_name_size() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_type_size() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_type_get_buffer_size(client: *mut jack_client_t,
                                          port_type:
                                          *const ::std::os::raw::c_char)
                                          -> usize;
}
extern "C" {
    pub fn jack_port_set_latency(port: *mut jack_port_t,
                                 arg1: jack_nframes_t);
}
extern "C" {
    pub fn jack_port_get_latency_range(port: *mut jack_port_t,
                                       mode: jack_latency_callback_mode_t,
                                       range: *mut jack_latency_range_t);
}
extern "C" {
    pub fn jack_port_set_latency_range(port: *mut jack_port_t,
                                       mode: jack_latency_callback_mode_t,
                                       range: *mut jack_latency_range_t);
}
extern "C" {
    pub fn jack_recompute_total_latencies(client: *mut jack_client_t)
                                          -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_port_get_latency(port: *mut jack_port_t) -> jack_nframes_t;
}
extern "C" {
    pub fn jack_port_get_total_latency(client: *mut jack_client_t,
                                       port: *mut jack_port_t)
                                       -> jack_nframes_t;
}
extern "C" {
    pub fn jack_recompute_total_latency(arg1: *mut jack_client_t,
                                        port: *mut jack_port_t)
                                        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_get_ports(client: *mut jack_client_t,
                          port_name_pattern: *const ::std::os::raw::c_char,
                          type_name_pattern: *const ::std::os::raw::c_char,
                          flags: ::std::os::raw::c_ulong)
                          -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jack_port_by_name(client: *mut jack_client_t,
                             port_name: *const ::std::os::raw::c_char)
                             -> *mut jack_port_t;
}
extern "C" {
    pub fn jack_port_by_id(client: *mut jack_client_t,
                           port_id: jack_port_id_t) -> *mut jack_port_t;
}
extern "C" {
    pub fn jack_frames_since_cycle_start(arg1: *const jack_client_t)
                                         -> jack_nframes_t;
}
extern "C" {
    pub fn jack_frame_time(arg1: *const jack_client_t) -> jack_nframes_t;
}
extern "C" {
    pub fn jack_last_frame_time(client: *const jack_client_t)
                                -> jack_nframes_t;
}
extern "C" {
    pub fn jack_get_cycle_times(client: *const jack_client_t,
                                current_frames: *mut jack_nframes_t,
                                current_usecs: *mut jack_time_t,
                                next_usecs: *mut jack_time_t,
                                period_usecs: *mut f32)
                                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jack_frames_to_time(client: *const jack_client_t,
                               arg1: jack_nframes_t) -> jack_time_t;
}
extern "C" {
    pub fn jack_time_to_frames(client: *const jack_client_t,
                               arg1: jack_time_t) -> jack_nframes_t;
}
extern "C" {
    pub fn jack_get_time() -> jack_time_t;
}
extern "C" {
    #[link_name = "jack_error_callback"]
    pub static mut jack_error_callback:
    ::std::option::Option<unsafe extern "C" fn(msg:
                                               *const ::std::os::raw::c_char)>;
}
extern "C" {
    pub fn jack_set_error_function(func:
                                   ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                              *const ::std::os::raw::c_char)>);
}
extern "C" {
    #[link_name = "jack_info_callback"]
    pub static mut jack_info_callback:
    ::std::option::Option<unsafe extern "C" fn(msg:
                                               *const ::std::os::raw::c_char)>;
}
extern "C" {
    pub fn jack_set_info_function(func:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *const ::std::os::raw::c_char)>);
}
extern "C" {
    pub fn jack_free(ptr: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
